/*
device:corot
some quick reference:

stream format: (for complete list, refer to: system/core/include/system/graphics-base-vx.x.h)
HAL_PIXEL_FORMAT_RGBA_8888 = 1,
HAL_PIXEL_FORMAT_RGBX_8888 = 2,
HAL_PIXEL_FORMAT_RGB_888 = 3,
HAL_PIXEL_FORMAT_RGB_565 = 4,
HAL_PIXEL_FORMAT_BGRA_8888 = 5,
HAL_PIXEL_FORMAT_YCBCR_422_SP = 16,
HAL_PIXEL_FORMAT_YCRCB_420_SP = 17,
HAL_PIXEL_FORMAT_YCBCR_422_I = 20,
HAL_PIXEL_FORMAT_RGBA_FP16 = 22,
HAL_PIXEL_FORMAT_RAW16 = 32,
HAL_PIXEL_FORMAT_BLOB = 33,
HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED = 34,
HAL_PIXEL_FORMAT_YCBCR_420_888 = 35,
HAL_PIXEL_FORMAT_RAW_OPAQUE = 36,
HAL_PIXEL_FORMAT_RAW10 = 37,
HAL_PIXEL_FORMAT_RAW12 = 38,
HAL_PIXEL_FORMAT_RGBA_1010102 = 43,
HAL_PIXEL_FORMAT_Y8 = 538982489,
HAL_PIXEL_FORMAT_Y16 = 540422489,
HAL_PIXEL_FORMAT_YV12 = 842094169,

stream dataspace: (for complete list, refer to: system/core/include/system/graphics-base-vx.x.h)
HAL_DATASPACE_JFIF = 257,
HAL_DATASPACE_V0_JFIF = 146931712,  // ((STANDARD_BT601_625 | TRANSFER_SMPTE_170M) | RANGE_FULL)
*/

{
    "supportDownCapture": true,
    "supportSortResult": true,
    "supportSortNotify": true,
    "maxPendingFrameNum": 40,
    // When APP supports DownCapture, mihal needs to discard the useless snapshot request front Burst.
    "InternalPreviewBufferQueueSize": 30,
    "MockCameraFwkStreamMaxBufferQueueSize": 30,
    // when mihal allocate a stream's GraBuffer, it will refresh a timer.
    // If no one else request the stream's GraBuffer for "BufferReclaimWaitMilliseconds",
    // then the idle buffers of that stream will be reclaimed to save memory
    "BufferReclaimWaitMilliseconds": 3000,
    // this is the time you wait for some buffers to get released when all the buffers of the
    // stream you are requesting are busy
    "RequestGraBufferTimeOutMilliseconds": 300,
    "InternalSnapshotStreamProperty": {
        "UpScaleSizeFactor": 2,
        "InternalRawStreamAspectRatio": 1.33,
        // NOTE: the sensor supported yuv output resolution
        // resolution of streams sent by framework should be in this option list with Â± tolerance
        "YuvStreamResolutionOptions": {
            "AspectRatioList": [1, 1.12851, 1.33333, 1.77777, 2.22222],
            // the tolerance shouldn't be too small. otherwise, mihal will choose the wrong
            // resolution. for example, in L2, when do Sr+Hdr, if you change frame ratio as 3:4,
            // then Qcom expects ouput stream size as 4080X3072, but 4080/3072=1.328125
            // which is not 4/3=1.33333. Therefore, we need some tolerance
            "Tolerance": 0.05
        },
        "RawStreamResolutionOptions": {
            "AspectRatioList": [1, 1.33, 1.77, 2.22],
            "Tolerance": 0.3
        }
    },
    "supportZSLQ": true,
    "supportStreaming": true,
    "supportMiviFullSceneRawCB": true,
    "messageStreamSize": {
        "app": {
            "MinVSESupportWidth": 640,
            "MinVSESupportHeight": 360
        },
        "mihal": {
            "HalVSESupportWidth": 1280,
            "HalVSESupportHeight": 960
        }
    },
    "FeatureList": {
        "Common": {
            "isSupportAiFlash": 0,
            "MFNRHDRSetting": {
                "MFNRNums": 5,
                "BokehMFNRNums":4
            },
            "isSupportUseAdrcGain": 0,
            "supportMFNRMaxNums": 6
        },
        "FeatureHDR": {
            // in normal hdr mode(not stagger hdr), we need to send mutiple requests
            // to vendor and merge these requests in mialgoengine, this variable sets
            // the minimum number of requests needed by mialgoengine to do
            // HDR processing, if the number of ev values returned by hdr checker is
            // less than this value, then this HDR snapshot is problematic
            "MinNumOfSnapshotRequiredByHDR": 2
        },
        "FeatureStaggerHDR": {
             "StaggerHDRCapSupportType": 3,
             "DXGCapSupport": 1,
             "DXGType": 6,
              // appmodule
              // 0xA3 MODE_CAPTURE  0xA7 MODE_PRO_PHOTO
              // 0xB4 MODE_PRO_VIDEO  0xBA MODE_DOC  0xA2 MODE_RECORD_VIDEO
             "DxgSupportMode":[163, 167, 180, 186, 162, 214, 164, 169, 190, 205]
         },
        "FeatureSR": {
            "NumOfSnapshotRequiredBySR": 8,
            "NumOfSnapshotRequiredBySRByZoom" : [0, 1, 40, 6],
            "isNeedGetCrop": 1,
            "SrRatioThreshold": 1.1,
            "isRawToRGB": 1
        },
        "FeatureSRHDR": {
            "NumOfSnapshotRequiredBySRHDR": 10,
            "DefaultExpValuesOfSRHDR": [0, 0, 0, 0, 0, 0, 0, 0, -6, 6]
        },
        "FeatureQuadRawSR": {
            "ISZQuadRawSRSupport": [0, 1],
            "ISZQuadRawSRIsoTh": [0, 1200],
            "ISZQuadRawSRZoomTh": [0, 2],
            "ISZQuadRawSRCROSSTALK": [0, 0],
            "ISZQuadRawSRPreviewISZ": [0, 1],
            "ISZQuadRawSRZSLSupport": [0, 1]
        },
        "FeatureSN": {
            "supportMfnrForSn": false,
            "supportFrontSnPlusFlash": false
        },
        "FeatureAINR": {
            "supportUltraWideForAINR": false,
            "NumOfSnapshotRequiredByAINR": 6,
            "LimitTimeByHDUltrRawUpper": 7000,
            "LimitTimeByHDUltrRawLower": 4000
        },
        "FeatureFusion": {
            "SrFusionZoomRegion": {
                "lowerBound": 3.0,
                "upperBound": 5.0
            },
            "MfnrFusionZoomRegion": {
                "lowerBound": 0.6,
                "upperBound": 1.0
            }
        },
        "FeatureHD": {
            // in K1, under superHD mode we want to use mfnr to get a high quality image
            // but if we set exposure time to a large value, it will take very long time to
            // snapshot, so we need to disable mfnr when we set a long exposure time.
            // this variable is the max exposure time to allow mfnr. the unit is nano second.
            "MfnrMaxExpTime": 250000000,
            // used in function findBiggestResolution()
            "SuperResolutionImageRatio": {
                "width": 4,
                "height": 3
            },
            "MaxQuickShotNums": 2,
            "MfnrZoomRatio": {
                "mfnrStartZoomRatio": 1.0,
                "mfnrEndZoomRatio": 10.0
            },
            "isSupportHdSr": 1,
            "isSupportSrReprocess": 1,
            "isNeedGetCropInMizone": 1,
            "isSupportSR10BIT":0
        },
        "Simple": {
            "HdrType": 2,
            "MFNRHDRSetting": {
                "MFNRNums": 5
            },
            "doFrontY2YScale": 1,
            "isSupportFrontHDRBokeh": 1
        },
        "ProfessionalMode": {
            "isSupportProfessionalProcessRaw": true
        },
        "Bokeh": {
            "isSupportSEBokeh": 1,
            "isSupportHDRBokeh": 1,
            "isSupportSwitchDualBokehDisCap": 0
        },
        "SuperHD": {
            "SuperResolToBinningResolFactor": 2,
            "RemosaicHDRSupport": 0,
            "RemosaicType": 2
        },
        "SuperNight": {
            "isFrontRawProcess": 1,
            "isSupportFrontSnPlusFlash": 0,
            "isSupportEll": 1
        },
        "Beauty": {
            "SuportPreviewFaceToCapture": 1
        }
    },
    "AttachPreview": {
        /**
        *Bit[0] - Support HD mode
        *Bit[1] - Support SAT mode
        *Bit[2] - Support BOKEH mode
        **/
        "AttachPreviewSupportMask": 7
    },
    /**
    *4kNoSatUfbc: 7
    *8kUfbc: 8
    **/
    "supportUFBCFormatSences": [7, 8],
    /**
    *0x8004 StreamConfigModeMiuiVideo 32772
    *0x801d StreamConfigModeMiuiVideo8k 32797
    **/
    "supportAFBCFormatSences": [32772, 32797],
    //Each stream 512M+256M memory default
    "CaptureBufferThreshold": 536870912,
    "CaptureSEBufferThreshold": 805306368,
    "CaptureSNBufferThreshold": 805306368,
    "HdQuickViewCacheMax": 15,
    // you can't just keep sending tasks to mialgoengine, we need to confine the num
    // of task in process, (one task means one photographer)
    // the total resource in mialgo
    "MialgoCapacity": 10,
    "MialgoTaskConsumption": {
        // the entries below show the reources cost by various photographer per snapshot.
        // If the sum of these resource reaches "MialgoCapacity", we will stop the app
        // This value supports input of one or two digits:
        // 2 or [2] (both low memory and high memory, the cost is 2.)
        // [8, 2]   (The cost is 8 for low memory device and 2 for high memory device.)
        "Photographer": 1,
        "BokehPhotographer": 2,
        "MihalMfnrBokehPhotographer": 4,
        "MDBokehPhotographer": 2,
        "HdrBokehPhotographer": 6,
        "SEBokehPhotographer": [4,2],
        "HdrPhotographer": 3,
        "HwmfPhotographer": 1,
        "MihalMFNRPhotographer": 1,
        "SupernightPhotographer": 4,
        "RawSupernightPhotographer": 4,
        "SrPhotographer": 4,
        "SrHdrPhotographer": 5,
        "StaggerRawHdrPhotographer": 3,
        "RawHdrPhotographer": 2,
        "FusionPhotographer": 3,
        "ProfessionalPhotographer": 1,
        "BurstPhotographer": 0,
        "AINRPhotographer": 4,
        "HdMFNRPhotographer": 5,
        "RemosaicMfnrPhotographer": 5,
        "HdRawHdrPhotographer": 2,
        "HdAINRPhotographer": 6
    },
    "QuickShot": {
        /**
        *Bit Mask for HighQualityQuickShotDelayTime configure
        *Bit[0 ~ 3]   - DelayTime XX ms of Bokeh MFNR in Back Camera
        *Bit[4 ~ 7]   - DelayTime XX ms of Bokeh MFNR in Front Camera
        *Bit[8 ~ 11]  - DelayTime XX ms of Back Normal Capture
        *Bit[12 ~ 15] - DelayTime XX ms of HDR in Front Camera
        *Bit[16 ~ 19] - DelayTime XX ms of HDR in Back Camera
        *Bit[20 ~ 23] - DelayTime XX ms of SuperNightSe in Back Camera
        *Bit[24 ~ 27] - DelayTime XX ms of SR in Back Camera
        *Bit[28 ~ 31] - DelayTime XX ms of Front Normal Capture
        *Bit[32 ~ 35] - DelayTime XX ms of MIHAL AINR in Back Camera
        *Bit[40 ~ 63] - reserv
        */
        "QuickShotDelayTimeMask": "0x0000000000",
        /**
        * Bit Mask Of HighQualityQuickShot Support
        * Bit[0]		 - Support MFSR/LLS in SAT mode
        * Bit[1]		 - Support HDR in SAT mode
        * Bit[2]		 - Support SR in SAT mode
        * Bit[3]		 - Support SuperNightSE in SAT mode
        * Bit[4~7]   - reserve
        * Bit[8]		 - Support Bokeh MFNR in Back Camera
        * Bit[9]		 - Support Bokeh HDR in Back Camera
        * Bit[10] 	- Support MFNR in Front Camera
        * Bit[11] 	- Support HDR in Front Camera
        * Bit[12] 	- Support Bokeh in Front Camera
        * Bit[13] 	- Support  Macro Mode
        * Bit[14~15]	 - reserve
        * Bit[16~19]	 - HighQualityQuickShot queue length(max number of HighQualityQuickShot)
        * Bit[20] 	 - Support reuse RDI buffer or not
        * Bit[21] 	 - Support Limit MFNR input frames or not
        * Bit[22~31]	 - reserve
        **/
        "QuickShotSupportedMask": "0xC30C07"
    },
    "BokehMD": {
        "BokehMDCaptureSize": {
            "BOKEH1X_4_3": {
                "WideCrop": [0, 0, 4096, 3072],
                "UWideCrop": [0, 0, 2880, 2160],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1X_16_9": {
                "WideCrop": [0, 384, 4096, 2304],
                "UWideCrop": [0, 268, 2880, 1624],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1X_FULL": {
                "WideCrop": [0, 616, 4096, 1840],
                "UWideCrop": [0, 432, 2880, 1296],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1_5X_4_3": {
                "WideCrop": [604, 456, 2888, 2160],
                "UWideCrop": [416, 312, 2048, 1536],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1_5X_16_9": {
                "WideCrop": [604, 724, 2888, 1624],
                "UWideCrop": [416, 504, 2048, 1152],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1_5X_FULL": {
                "WideCrop": [604, 888, 2888, 1296],
                "UWideCrop": [416, 600, 2048, 920],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            }
        },
        "BokehMDPreviewSize": {
            "BOKEH1X_4_3": {
                "WideCrop": [0, 0, 4096, 3072],
                "UWideCrop": [200, 152, 2880, 2160],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1X_16_9": {
                "WideCrop": [0, 384, 4096, 2304],
                "UWideCrop": [200, 420, 2880, 1624],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1X_FULL": {
                "WideCrop": [0, 616, 4096, 1840],
                "UWideCrop": [200, 584, 2880, 1296],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1_5X_4_3": {
                "WideCrop": [604, 456, 2888, 2160],
                "UWideCrop": [616, 464, 2048, 1536],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1_5X_16_9": {
                "WideCrop": [604, 724, 2888, 1624],
                "UWideCrop": [616, 656, 2048, 1152],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            },
            "BOKEH1_5X_FULL": {
                "WideCrop": [604, 888, 2888, 1296],
                "UWideCrop": [616, 772, 2048, 920],
                "Fallback_WideCrop": [0,0,0,0],
                "Fallback_UWideCrop": [0,0,0,0]
            }
        },
        "BokehExifInfo": {
            "BokehMDExif": {
                "BOKEH_MD_50MM": [0.95, 50.0, 50.0],
                "BOKEH_MD_90MM": [2.3, 90.0, 90.0],
                "BOKEH_MD_35MM": [1.4, 35.0, 35.0],
                "BOKEH_MD_75MM": [1.25, 75.0, 75.0]
            },
            "BokehExif": {
                "BOKEH_23MM": [0.0, 0.0, 23.0],
                "BOKEH_35MM": [0.0, 0.0, 35.0],
                "BOKEH_50MM": [0.0, 0.0, 50.0],
                "BOKEH_75MM": [0.0, 0.0, 75.0]
            }
        }
    },
    "UltraHdrSupported": true,
    "UltraHdr": {
        "Supported": true,
        "Version": "2.0"
    },
    "isSupport3rdHLGStreaming":false,
    "MaxPendingRequest": 3,
    "RealtimePostProcess": {
        "PerfForceError": {
            "SkipThresholds": [18, 21],
            "SkipNums": [3, 2],
            "FrameDelayNums": 25,
            "SkipEnable": 1
        }
    }
}
